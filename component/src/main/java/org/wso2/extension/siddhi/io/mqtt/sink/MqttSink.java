/*
 *  Copyright (c) 2017 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *  WSO2 Inc. licenses this file to you under the Apache License,
 *  Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 *
 */
package org.wso2.extension.siddhi.io.mqtt.sink;

import org.apache.log4j.Logger;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.persist.MqttDefaultFilePersistence;
import org.wso2.extension.siddhi.io.mqtt.util.MqttConstants;
import org.wso2.siddhi.annotation.Example;
import org.wso2.siddhi.annotation.Extension;
import org.wso2.siddhi.annotation.Parameter;
import org.wso2.siddhi.annotation.util.DataType;
import org.wso2.siddhi.core.config.SiddhiAppContext;
import org.wso2.siddhi.core.exception.ConnectionUnavailableException;
import org.wso2.siddhi.core.stream.output.sink.Sink;
import org.wso2.siddhi.core.util.config.ConfigReader;
import org.wso2.siddhi.core.util.transport.DynamicOptions;
import org.wso2.siddhi.core.util.transport.Option;
import org.wso2.siddhi.core.util.transport.OptionHolder;
import org.wso2.siddhi.query.api.definition.StreamDefinition;

import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
 * {@code MqttSink } Handle the Mqtt publishing tasks.
 */

@Extension(
        name = "mqtt",
        namespace = "sink",
        description = "The mqtt sink publishes the events into a mqtt broker ",
        parameters = {
                @Parameter(
                        name = "url",
                        description = "MQTT broker ur,It is used to connect to the MQTT broker " +
                                "This is a mandatory parameter ",
                        type = {DataType.STRING}),
                @Parameter(
                        name = "username",
                        description = "Username of the mqtt broker ",
                        type = {DataType.STRING},
                        optional = true, defaultValue = "null"),
                @Parameter(
                        name = "password",
                        description = "password of the mqtt broker ",
                        type = {DataType.STRING},
                        optional = true, defaultValue = "empty"),
                @Parameter(
                        name = "client.id",
                        description = "client identifier is used by the server to identify a client, " +
                                "If user has not given the client.id then the system automatically " +
                                "generated the client.id",
                        type = {DataType.STRING},
                        optional = true, defaultValue = "generated by the system"),
                @Parameter(
                        name = "topic",
                        description = "Messages in MQTT are published on topics " +
                                "This is a mandatory parameter.",
                        type = {DataType.STRING},
                        dynamic = true),
                @Parameter(
                        name = "quality.of.service",
                        description = "QoS defines how hard the broker/client will try to ensure that a " +
                                "message is received. It can takes the value as 0 or 1 or 2 " +
                                "value 0 guarantees that the message will be delivered at most once" +
                                "value 1 guarantees that the message will be delivered at least once" +
                                "value 2 guarantees that the message will be delivered only once.",
                        type = {DataType.STRING},
                        dynamic = true,
                        optional = true, defaultValue = "1"),
                @Parameter(
                        name = "clean.session",
                        description = "clean.session indicates the broker, whether the client wants " +
                                "to establish a persistent session or not, if clean.session is set to false," +
                                " then the connection is treated as durable. If clean.session is true, then " +
                                "all subscriptions will be removed for the client when it disconnects.",
                        type = {DataType.BOOL},
                        optional = true, defaultValue = "true"
                ),
                @Parameter(
                        name = "message.retain",
                        description = "Publisher can tell the broker to either keep the last message or not on " +
                                "that topic by setting the retained message.",
                        type = {DataType.STRING},
                        dynamic = true,
                        optional = true, defaultValue = "false"),
                @Parameter(
                        name = "keep.alive",
                        description = "The maximum number of seconds the connection between the MQTT client and " +
                                "the broker",
                        type = {DataType.INT},
                        optional = true, defaultValue = "60"),
                @Parameter(
                        name = "connection.timeout",
                        description = "The maximum number of seconds that the MQTT client should spend attempting" +
                                " to connect to the MQTT broker",
                        type = {DataType.INT},
                        optional = true, defaultValue = "30")

        },
        examples =
                {
                        @Example(description = "Following example illustrates how to publish to a MQTT topic.",
                                syntax = "@sink(type='mqtt', url= 'tcp://localhost:1883', " +
                                        "topic='mqtt_topic', clean.session='true', message.retain='false', " +
                                        "quality.of.service= '1', keep.alive= '60',connection.timeout='30'" +
                                        "@map(type='xml'))" +
                                        "Define stream BarStream (symbol string, price float, volume long);")
                }
)


public class MqttSink extends Sink {
    private static final Logger log = Logger.getLogger(MqttSink.class);

    private String brokerURL;
    private Option topicOption;
    private String clientId;
    private String userName;
    private String userPassword;
    private Option qosOption;
    private boolean cleanSession;
    private int keepAlive;
    private int connectionTimeout;
    private MqttClient client;
    private Option messageRetainOption;
    private StreamDefinition streamDefinition;

    @Override
    protected void init(StreamDefinition streamDefinition, OptionHolder optionHolder, ConfigReader configReader,
                        SiddhiAppContext siddhiAppContext) {
        this.streamDefinition = streamDefinition;
        this.brokerURL = optionHolder.validateAndGetStaticValue(MqttConstants.MQTT_BROKER_URL);
        this.clientId = optionHolder.validateAndGetStaticValue(MqttConstants.CLIENT_ID,
                MqttConstants.EMPTY_STRING);
        this.topicOption = optionHolder.validateAndGetOption(MqttConstants.MESSAGE_TOPIC);
        this.userName = optionHolder.validateAndGetStaticValue(MqttConstants.MQTT_BROKER_USERNAME,
                MqttConstants.DEFAULT_USERNAME);
        this.userPassword = optionHolder.validateAndGetStaticValue(MqttConstants.MQTT_BROKER_PASSWORD,
                MqttConstants.EMPTY_STRING);
        this.qosOption = optionHolder.getOrCreateOption(MqttConstants.MESSAGE_QOS, MqttConstants.DEFAULT_QOS);
        this.keepAlive = Integer.parseInt(optionHolder.validateAndGetStaticValue
                (MqttConstants.CONNECTION_KEEP_ALIVE_INTERVAL,
                        MqttConstants.DEFAULT_CONNECTION_KEEP_ALIVE_INTERVAL));
        this.connectionTimeout = Integer.parseInt(optionHolder.validateAndGetStaticValue
                (MqttConstants.CONNECTION_TIMEOUT_INTERVAL,
                        MqttConstants.DEFAULT_CONNECTION_TIMEOUT_INTERVAL));
        this.messageRetainOption = optionHolder.getOrCreateOption(MqttConstants.MQTT_MESSAGE_RETAIN,
                MqttConstants.DEFAULT_MESSAGE_RETAIN);
        this.cleanSession = Boolean.parseBoolean(optionHolder.validateAndGetStaticValue
                    (MqttConstants.CLEAN_SESSION, MqttConstants.DEFAULT_CLEAN_SESSION));
    }

    @Override
    public Class[] getSupportedInputEventClasses() {
        return new Class[]{Byte[].class, String.class};
    }

    @Override
    public String[] getSupportedDynamicOptions() {
        return new String[]{MqttConstants.MESSAGE_TOPIC, MqttConstants.MESSAGE_QOS,
                MqttConstants.MQTT_MESSAGE_RETAIN};
    }

    @Override
    public void connect() throws ConnectionUnavailableException {
        try {
            MqttDefaultFilePersistence persistence = new  MqttDefaultFilePersistence();
            if (clientId.isEmpty()) {
                clientId = MqttClient.generateClientId();
            }
            client = new MqttClient(brokerURL, clientId, persistence);
            MqttConnectOptions connectionOptions = new MqttConnectOptions();
            connectionOptions.setUserName(userName);
            connectionOptions.setPassword(userPassword.toCharArray());
            connectionOptions.setCleanSession(cleanSession);
            connectionOptions.setKeepAliveInterval(keepAlive);
            connectionOptions.setConnectionTimeout(connectionTimeout);
            client.connect(connectionOptions);

        } catch (MqttException e) {
            throw new ConnectionUnavailableException(
                    "Error while connecting with the Mqtt server, Check the broker url = " + brokerURL +
                            " defined in " + streamDefinition, e);
        }
    }

    @Override
    public void disconnect() {
        try {
            client.disconnect();
            log.debug("Disconnected from MQTT broker: " + brokerURL);
        } catch (MqttException e) {
            log.error("Could not disconnect from MQTT broker: " + brokerURL, e);
        } finally {
            try {
                client.close();
            } catch (MqttException e) {
                log.error("Could not close connection with MQTT broker: " + brokerURL, e);
            }
        }
    }

    @Override
    public void destroy() {

    }

    public void publish(Object payload, DynamicOptions dynamicOptions) throws ConnectionUnavailableException {
        try {
            MqttMessage message = new MqttMessage();
            byte[] byteArray;
            if (payload instanceof byte[]) {
                byteArray = (byte[]) payload;
            } else {
                byteArray = payload.toString().getBytes("UTF-8");
            }
            message.setPayload(byteArray);
            int qos = Integer.parseInt(qosOption.getValue(dynamicOptions));
            boolean messageRetain = Boolean.parseBoolean(messageRetainOption.getValue(dynamicOptions));
            message.setQos(qos);
            message.setRetained(messageRetain);
            String topic = topicOption.getValue(dynamicOptions);
            client.publish(topic, message);
        } catch (MqttException e) {
            log.error("Error occurred when publishing message to the MQTT broker: " + brokerURL + " in "
                    + streamDefinition, e);
        } catch (UnsupportedEncodingException e) {
            log.error("Event could not be encoded in UTF-8, hence it could not be published to MQTT broker: "
                    + brokerURL + " in " + streamDefinition, e);
        }
    }


    public Map<String, Object> currentState() {
        return null;
    }


    public void restoreState(Map<String, Object> map) {

    }
}

